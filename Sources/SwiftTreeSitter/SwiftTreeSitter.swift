import Foundation
import TreeSitter

/// The latest ABI version that is supported by the current version of the
/// library.
///
/// When Languages are generated by the Tree-sitter CLI, they are
/// assigned an ABI version number that corresponds to the current CLI version.
/// The Tree-sitter library is generally backwards-compatible with languages
/// generated using older CLI versions, but is not forwards-compatible.
public let LANGUAGE_VERSION = TREE_SITTER_LANGUAGE_VERSION

/// The earliest ABI version that is supported by the current version of the
/// library.
public let MIN_COMPATIBLE_LANGUAGE_VERSION = TREE_SITTER_MIN_COMPATIBLE_LANGUAGE_VERSION

public struct InputEdit {
    var rawInputEdit: TSInputEdit
    
    /// For internal use only
    init(raw: TSInputEdit) {
        self.rawInputEdit = raw
    }

    public init(
        startByte: UInt32,
        oldEndByte: UInt32,
        newEndByte: UInt32,
        startPoint: Point,
        oldEndPoint: Point,
        newEndPoint: Point
    ) {
        rawInputEdit = TSInputEdit(
            start_byte: startByte,
            old_end_byte: oldEndByte,
            new_end_byte: newEndByte,
            start_point: startPoint.rawPoint,
            old_end_point: oldEndPoint.rawPoint,
            new_end_point: newEndPoint.rawPoint
        )
    }
    
    public var startByte: CUnsignedInt {
        rawInputEdit.start_byte
    }
    
    public var oldEndByte: CUnsignedInt {
        rawInputEdit.old_end_byte
    }
    
    public var newEndByte: CUnsignedInt {
        rawInputEdit.new_end_byte
    }
    
    public var startPoint: Point {
        Point(
            row: rawInputEdit.start_point.row,
            column: rawInputEdit.start_point.column
        )
    }
    
    public var oldEndPoint: Point {
        Point(
            row: rawInputEdit.old_end_point.row,
            column: rawInputEdit.old_end_point.column
        )
    }
    
    public var newEndPoint: Point {
        Point(
            row: rawInputEdit.new_end_point.row,
            column: rawInputEdit.new_end_point.column
        )
    }
}

public struct Point {
    let rawPoint: TSPoint
    
    /// For internal use only
    init(raw: TSPoint) {
        rawPoint = raw
    }

    public init(row: CUnsignedInt, column: CUnsignedInt) {
        rawPoint = TSPoint(row: row, column: column)
    }
    
    public var row: CUnsignedInt {
        rawPoint.row
    }
    
    public var column: CUnsignedInt {
        rawPoint.column
    }
}

extension Point: Comparable {
    public static func < (lhs: Point, rhs: Point) -> Bool {
        lhs.row < rhs.row || (lhs.row == rhs.row && lhs.column < rhs.column)
    }
    
    public static func == (lhs: Point, rhs: Point) -> Bool {
        lhs.row == rhs.row && lhs.column == rhs.column
    }
}

extension Point: Hashable {
    public func hash(into hasher: inout Hasher) {
        hasher.combine(row)
        hasher.combine(column)
    }
}

/// A wrapper around Tree sitter's `TSRange`.
/// We use the prefix `STS` because swift already has a `Range` type.
public struct STSRange {
    let rawRange: TSRange
    
    /// For internal use only
    init(raw: TSRange) {
        rawRange = raw
    }
    
    public init(
        startPoint: Point,
        endPoint: Point,
        startByte: CUnsignedInt,
        endByte: CUnsignedInt
    ) {
        self.rawRange = TSRange(
            start_point: startPoint.rawPoint,
            end_point: endPoint.rawPoint,
            start_byte: startByte,
            end_byte: endByte
        )
    }
    
    public var startPoint: Point {
        Point(
            row: rawRange.start_point.row,
            column: rawRange.start_point.column
        )
    }
    
    public var endPoint: Point {
        Point(
            row: rawRange.end_point.row,
            column: rawRange.end_point.column
        )
    }
    
    public var startByte: CUnsignedInt {
        rawRange.start_byte
    }
    
    public var endByte: CUnsignedInt {
        rawRange.end_byte
    }
}

extension STSRange: Comparable {
    public static func < (lhs: STSRange, rhs: STSRange) -> Bool {
        lhs.startByte < rhs.startByte ||
            (lhs.startByte == rhs.startByte && lhs.endByte < rhs.endByte)
    }
    
    public static func == (lhs: STSRange, rhs: STSRange) -> Bool {
        lhs.startPoint == rhs.endPoint && lhs.startByte == rhs.endByte
    }
}

extension STSRange: Hashable {
    public func hash(into hasher: inout Hasher) {
        hasher.combine(self.startByte)
        hasher.combine(self.endByte)
    }
}
